#!/usr/bin/env python3
"""
Timetable Visualization Tool

This script creates visualizations of the timetable generated by the timetable_generator.py script.
It provides both a heatmap view and a detailed view of schedules for teachers and rooms.
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np
import os
from collections import defaultdict
import seaborn as sns

def load_timetable(file_path='master_timetable.csv'):
    """Load the timetable data from CSV file"""
    if not os.path.exists(file_path):
        print(f"Error: Timetable file '{file_path}' not found.")
        print("Please run the timetable_generator.py script first.")
        return None
        
    return pd.read_csv(file_path)

def create_heatmap(timetable_df):
    """Create a heatmap showing class density by day and time slot"""
    if timetable_df is None:
        return
        
    # Count classes per day and slot
    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    heatmap_data = pd.pivot_table(
        timetable_df, 
        values='Course', 
        index='Day', 
        columns='Slot',
        aggfunc='count', 
        fill_value=0
    )
    
    # Reorder days
    heatmap_data = heatmap_data.reindex(day_order)
    
    # Create heatmap
    plt.figure(figsize=(12, 8))
    ax = sns.heatmap(
        heatmap_data, 
        cmap="YlGnBu",
        annot=True, 
        fmt="d", 
        linewidths=.5, 
        cbar_kws={'label': 'Number of Classes'}
    )
    ax.set_title('Class Density by Day and Time Slot', fontsize=16)
    ax.set_xlabel('Time Slot')
    ax.set_ylabel('Day')
    
    plt.tight_layout()
    plt.savefig('timetable_heatmap.png', dpi=300, bbox_inches='tight')
    print("Saved heatmap visualization to 'timetable_heatmap.png'")
    plt.close()

def create_teacher_load_chart(timetable_df, max_teachers=20):
    """Create a bar chart showing teaching load by teacher"""
    if timetable_df is None:
        return
        
    # Count classes per teacher
    teacher_loads = timetable_df['Teacher'].value_counts().reset_index()
    teacher_loads.columns = ['Teacher', 'Classes']
    teacher_loads = teacher_loads.head(max_teachers)  # Limit to top teachers
    
    # Create bar chart
    plt.figure(figsize=(14, 8))
    bars = plt.bar(
        [t.split('@')[0] for t in teacher_loads['Teacher']], 
        teacher_loads['Classes'],
        color='skyblue'
    )
    
    # Add count labels above bars
    for bar in bars:
        height = bar.get_height()
        plt.text(
            bar.get_x() + bar.get_width()/2.,
            height + 0.1,
            str(int(height)),
            ha='center', 
            va='bottom'
        )
    
    plt.title('Teaching Load by Teacher (Top 20)', fontsize=16)
    plt.xlabel('Teacher')
    plt.ylabel('Number of Classes')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    
    plt.savefig('teacher_load.png', dpi=300, bbox_inches='tight')
    print("Saved teacher load chart to 'teacher_load.png'")
    plt.close()

def create_department_load_chart(timetable_df):
    """Create a bar chart showing teaching load by department"""
    if timetable_df is None or 'Department' not in timetable_df.columns:
        print("Department information not available in timetable data")
        return
        
    # Count classes per department
    dept_loads = timetable_df.groupby('Department').size().reset_index()
    dept_loads.columns = ['Department', 'Classes']
    dept_loads = dept_loads.sort_values('Classes', ascending=False)
    
    # Create bar chart
    plt.figure(figsize=(14, 8))
    bars = plt.bar(
        dept_loads['Department'],
        dept_loads['Classes'],
        color='lightgreen'
    )
    
    # Add count labels above bars
    for bar in bars:
        height = bar.get_height()
        plt.text(
            bar.get_x() + bar.get_width()/2.,
            height + 0.1,
            str(int(height)),
            ha='center', 
            va='bottom'
        )
    
    plt.title('Teaching Load by Department', fontsize=16)
    plt.xlabel('Department')
    plt.ylabel('Number of Classes')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    
    plt.savefig('department_load.png', dpi=300, bbox_inches='tight')
    print("Saved department load chart to 'department_load.png'")
    plt.close()

def create_room_usage_chart(timetable_df, max_rooms=20):
    """Create a bar chart showing room usage"""
    if timetable_df is None:
        return
        
    # Count classes per room
    room_usage = timetable_df['Room'].value_counts().reset_index()
    room_usage.columns = ['Room', 'Classes']
    room_usage = room_usage.head(max_rooms)  # Limit to top rooms
    
    # Create bar chart
    plt.figure(figsize=(14, 8))
    bars = plt.bar(
        room_usage['Room'], 
        room_usage['Classes'],
        color='lightgreen'
    )
    
    # Add count labels above bars
    for bar in bars:
        height = bar.get_height()
        plt.text(
            bar.get_x() + bar.get_width()/2.,
            height + 0.1,
            str(int(height)),
            ha='center', 
            va='bottom'
        )
    
    plt.title('Room Usage (Top 20)', fontsize=16)
    plt.xlabel('Room')
    plt.ylabel('Number of Classes')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    
    plt.savefig('room_usage.png', dpi=300, bbox_inches='tight')
    print("Saved room usage chart to 'room_usage.png'")
    plt.close()

def create_course_distribution_chart(timetable_df, max_courses=20):
    """Create a bar chart showing course distribution"""
    if timetable_df is None:
        return
        
    # Count occurrences per course
    course_dist = timetable_df['Course'].value_counts().reset_index()
    course_dist.columns = ['Course', 'Classes']
    course_dist = course_dist.head(max_courses)  # Limit to top courses
    
    # Create bar chart
    plt.figure(figsize=(14, 8))
    bars = plt.bar(
        course_dist['Course'], 
        course_dist['Classes'],
        color='salmon'
    )
    
    # Add count labels above bars
    for bar in bars:
        height = bar.get_height()
        plt.text(
            bar.get_x() + bar.get_width()/2.,
            height + 0.1,
            str(int(height)),
            ha='center', 
            va='bottom'
        )
    
    plt.title('Course Distribution (Top 20)', fontsize=16)
    plt.xlabel('Course')
    plt.ylabel('Number of Classes')
    plt.xticks(rotation=90)
    plt.tight_layout()
    
    plt.savefig('course_distribution.png', dpi=300, bbox_inches='tight')
    print("Saved course distribution chart to 'course_distribution.png'")
    plt.close()

def create_teacher_timetable_grid(timetable_df, teacher_email, output_file=None):
    """Create a grid showing the timetable for a specific teacher"""
    if timetable_df is None:
        return
        
    # Filter data for the specified teacher
    teacher_df = timetable_df[timetable_df['Teacher'] == teacher_email]
    
    if teacher_df.empty:
        print(f"No schedule found for teacher: {teacher_email}")
        return
        
    # Create a grid for the teacher's schedule
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    slots = range(1, 14)  # Slots 1-13
    
    # Create a 2D grid (rows: days, columns: slots)
    grid_data = np.empty((len(days), len(slots)), dtype=object)
    grid_data[:] = ''
    
    # Fill the grid with course and room information
    for _, row in teacher_df.iterrows():
        day_idx = days.index(row['Day'])
        slot_idx = row['Slot'] - 1  # Adjust for 0-indexing
        grid_data[day_idx, slot_idx] = f"{row['Course']}\n{row['Room']}"
    
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(16, 8))
    ax.set_axis_off()
    
    # Create the table
    teacher_name = teacher_email.split('@')[0]
    
    # Add department info if available
    dept_info = ""
    if 'Department' in teacher_df.columns and not teacher_df['Department'].empty:
        dept_info = f" ({teacher_df['Department'].iloc[0]})"
    
    table = ax.table(
        cellText=grid_data,
        rowLabels=days,
        colLabels=[f"Slot {i}" for i in slots],
        cellLoc='center',
        loc='center',
        bbox=[0, 0, 1, 1]
    )
    
    # Style the table
    table.auto_set_font_size(False)
    table.set_fontsize(9)
    table.scale(1, 1.5)
    
    # Color cells with classes
    for i in range(len(days)):
        for j in range(len(slots)):
            cell = table[(i+1, j)]
            if grid_data[i, j]:
                cell.set_facecolor('lightblue')
                cell.set_text_props(weight='bold')
            
    plt.title(f"Schedule for {teacher_name}{dept_info}", fontsize=16)
    plt.tight_layout()
    
    # Save or show the figure
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved teacher schedule to '{output_file}'")
    else:
        output_file = f"schedule_{teacher_name}.png"
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved teacher schedule to '{output_file}'")
    
    plt.close()

def create_department_timetable_grid(timetable_df, department_name, output_file=None):
    """Create a grid showing the aggregated timetable for a department"""
    if timetable_df is None or 'Department' not in timetable_df.columns:
        print("Department information not available in timetable data")
        return
        
    # Filter data for the specified department
    dept_df = timetable_df[timetable_df['Department'] == department_name]
    
    if dept_df.empty:
        print(f"No schedule found for department: {department_name}")
        return
        
    # Create a grid for the department's schedule
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    slots = range(1, 14)  # Slots 1-13
    
    # Create a figure large enough for all days and slots
    plt.figure(figsize=(18, 10))
    
    # We'll use a table-based approach for the visualization
    cell_data = []
    for day in days:
        row_data = []
        for slot in slots:
            # Get all classes for this day and slot
            day_slot_classes = dept_df[(dept_df['Day'] == day) & (dept_df['Slot'] == slot)]
            
            if day_slot_classes.empty:
                row_data.append('')
            else:
                # Format class info
                class_text = '\n'.join([
                    f"{row['Course']} ({row['Teacher'].split('@')[0]})" 
                    for _, row in day_slot_classes.iterrows()
                ])
                row_data.append(class_text)
        cell_data.append(row_data)
    
    # Create the table
    ax = plt.gca()
    ax.axis('off')
    table = ax.table(
        cellText=cell_data,
        rowLabels=days,
        colLabels=[f"Slot {i}" for i in slots],
        cellLoc='center',
        loc='center',
        bbox=[0, 0, 1, 1]
    )
    
    # Style the table
    table.auto_set_font_size(False)
    table.set_fontsize(8)
    table.scale(1, 1.8)
    
    # Color cells with classes
    for i in range(len(days)):
        for j in range(len(slots)):
            cell = table[(i+1, j)]
            if cell_data[i][j]:
                cell.set_facecolor('#e6f2ff')  # Light blue
                cell.set_text_props(weight='bold')
    
    # Create a clean version of department name for filename
    safe_dept_name = ''.join(c if c.isalnum() else '_' for c in department_name)
    
    plt.title(f"Schedule for {department_name} Department", fontsize=16)
    plt.tight_layout()
    
    # Save the visualization
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved department schedule to '{output_file}'")
    else:
        output_file = f"schedule_dept_{safe_dept_name}.png"
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved department schedule to '{output_file}'")
    
    plt.close()

def create_charts():
    """Create all visualizations"""
    timetable_df = load_timetable()
    if timetable_df is None:
        return
    
    print(f"Loaded timetable with {len(timetable_df)} classes")
    
    # Create visualizations
    create_heatmap(timetable_df)
    create_teacher_load_chart(timetable_df)
    create_room_usage_chart(timetable_df)
    create_course_distribution_chart(timetable_df)
    
    # Create department load chart if department info is available
    if 'Department' in timetable_df.columns:
        create_department_load_chart(timetable_df)
        
        # Create visualizations for top departments
        top_departments = timetable_df['Department'].value_counts().head(5).index.tolist()
        for dept in top_departments:
            if dept:  # Skip empty department names
                create_department_timetable_grid(timetable_df, dept)
    
    # Create timetable grids for a few teachers
    # Get the top 5 teachers by number of classes
    top_teachers = timetable_df['Teacher'].value_counts().head(5).index.tolist()
    for teacher in top_teachers:
        create_teacher_timetable_grid(timetable_df, teacher)
    
    print("All visualizations completed successfully.")

if __name__ == "__main__":
    create_charts() 